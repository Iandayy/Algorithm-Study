# 섹션2 : Big O Notation 

## Big-O의 수학적 정의와 계산법 <br>
어떤 함수 f(n)의 Big-O notation이 O(g(n))라는 것은, n의 값이 일정 수준이 넘어가면(충분히 많은 아이템을 사용한다면)그 이상의 어떤 n을 대입하여도 c*g(n)보다 결과값이 작은 상수 c가 존재한다는 뜻이다.<br>

<br>

- f(n)이 n에 대한 d차식이면, f(n)은 O(n^d)이다.
- 가능한 가장 작은 notation을 사용하여야 한다. <br>
=> O(n^2)도 되고 O(n)도 된다면 가장 작은 O(n)을 사용
- 가능한 가장 간단한 표기를 사용하여야 한다. <br>
=> O(3n+4)도 되고 O(n)도 된다면 가장 간단한 O(n)을 사용  <br> <br>

___


 <br> <br>
O(1) : 입력값에 상관없이 일정한 실행시간의 알고리즘이라 할 수 있다. 하지만 상수 시간에 실행된다 해도 상수값이 상상 이상으로 클 경우 사실상 일정한 시간의 의미가 없다. 

O(log n) : 로그는 매우 큰 입력값에서도 크게 영향을 받지 않는 편이다. 매우 견고한 알고리즘으로 이진 탐색의 경우가 이에 해당한다.

O(n) : 알고리즘을 수행하는데 걸리는 시간은 입력값에 비례한다. 이러한 알고리즘을 선형 시간 알고리즘이라 부른다. 정렬되지 않은리스트에서 최대 또는 최솟값을 찾는 경우가 해당되며 모든 입렵값을 적어도 한 번 이상은 살펴봐야 한다.

O (n log n) : 병합 정렬등의 대부분 효율이 좋은 알고리즘이 이에 해당 한다. 아무리 좋은 알고리즘이라 할지라도 n log n 보다 빠를 수 없다. 입력값이 최선일 경우, 비교를 건너 뛰어 O(n)이 될 수 있다.

O(n^2)  : 버블 정렬 같은 비효율저긴 정렬 알고리즘이 이에 해당 한다.

O(2^n) : 피보나치의 수를 재귀로 계산하는 알고리즘이 이에 해당 한다. n^2와 혼동되는 경우가 있는데 2^n이 훨씬 더 크다.

O(n!) : 가장 느린 알고리즘으로 입력값이 조금만 커져도 계산이 어렵다.
<br><br><br>
___

<br><br><br>
빅오 표기법은 시간 복잡도 외에도 공간 복잡도를 표현하는데 널리 쓰인다. 

알고리즘은  "시간과 공간이 트레이드오프 관계이다" (트레이드 오프 : 하나가 증가하면 다른 하나는 감소한다.)

즉, 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다는 것이다